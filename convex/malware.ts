import { v } from 'convex/values'
import { zipSync } from 'fflate'
import { internal } from './_generated/api'
import { checkFileHash, getAnalysisResult, uploadFile, type VTScanResult } from './lib/virustotal'
import { Id } from './_generated/dataModel'
import { internalAction, internalMutation } from './_generated/server'

export const scanSkillVersion = internalAction({
    args: {
        skillId: v.id('skills'),
        versionId: v.id('skillVersions'),
        files: v.array(
            v.object({
                path: v.string(),
                sha256: v.string(),
                storageId: v.id('_storage'),
            })
        ),
    },
    handler: async (ctx, args) => {
        console.log(`Scanning skill ${args.skillId} version ${args.versionId} with VirusTotal...`)

        try {
            // 1. Zip the entire skill
            console.log(`Zipping ${args.files.length} files for VirusTotal scan...`)
            const zipEntries: Record<string, Uint8Array> = {}
            for (const file of args.files) {
                const blob = await ctx.storage.get(file.storageId)
                if (blob) {
                    zipEntries[file.path] = new Uint8Array(await blob.arrayBuffer())
                }
            }

            const zipBuffer = zipSync(zipEntries)
            const zipBlob = new Blob([zipBuffer as any], { type: 'application/zip' })

            // 2. Compute SHA256 of the zip file
            const zipHashBuffer = await crypto.subtle.digest('SHA-256', zipBuffer as any)
            const zipHash = Array.from(new Uint8Array(zipHashBuffer))
                .map((b) => b.toString(16).padStart(2, '0'))
                .join('')

            console.log(`Checking VirusTotal for zip hash: ${zipHash}`)

            // 3. Check if this zip has been scanned before
            let result = await checkFileHash(zipHash)

            if (result.status === 'unknown') {
                console.log(`Zip unknown to VirusTotal. Uploading...`)
                const analysisId = await uploadFile('skill_bundle.zip', zipBlob)
                if (!analysisId) {
                    console.error('Failed to upload skill bundle to VirusTotal')
                    return
                }

                console.log(`Uploaded skill bundle, analysis ID: ${analysisId}. Polling for results...`)

                // Poll for max 3 minutes (18 * 10s)
                for (let i = 0; i < 18; i++) {
                    await new Promise((resolve) => setTimeout(resolve, 10000))
                    const pollResult = await getAnalysisResult(analysisId)
                    if (pollResult.status !== 'queued' && pollResult.status !== 'in_progress') {
                        result = pollResult as VTScanResult
                        break
                    }
                }
            }

            if (result && result.status !== 'unknown' && result.status !== 'error') {
                console.log(`Scan complete. Status: ${result.status}`)
                await ctx.runMutation(internal.malware.applyScanResults, {
                    skillId: args.skillId,
                    versionId: args.versionId,
                    maliciousFiles:
                        result.status === 'malicious' ? [{ path: 'skill_bundle.zip', sha256: zipHash, stats: result }] : [],
                    suspiciousFiles:
                        result.status === 'suspicious' ? [{ path: 'skill_bundle.zip', sha256: zipHash, stats: result }] : [],
                })
            } else {
                if (result.status === 'unknown') {
                    console.warn('VirusTotal analysis timed out or remained unknown.')
                } else if (result.status === 'error') {
                    console.error('VirusTotal scan resulted in an error.')
                }
                await ctx.runMutation(internal.malware.applyScanResults, {
                    skillId: args.skillId,
                    versionId: args.versionId,
                    maliciousFiles: [],
                    suspiciousFiles: [],
                })
            }
        } catch (error) {
            console.error('Error during skill scanning', error)
        }
    },
})

export const applyScanResults = internalMutation({
    args: {
        skillId: v.id('skills'),
        versionId: v.id('skillVersions'),
        maliciousFiles: v.array(v.any()),
        suspiciousFiles: v.array(v.any()),
    },
    handler: async (ctx, args) => {
        const skill = await ctx.db.get(args.skillId)
        if (!skill) return

        const flags = new Set(skill.moderationFlags ?? [])

        // Remove "pending" flag if it exists
        flags.delete('vt.pending')

        if (args.maliciousFiles.length > 0) {
            flags.add('vt.malicious')
            flags.add('blocked.malware')
        }

        if (args.suspiciousFiles.length > 0) {
            flags.add('vt.suspicious')
        }

        const patch: any = {
            moderationFlags: flags.size > 0 ? Array.from(flags) : undefined,
            updatedAt: Date.now(),
        }

        // Auto-hide if malicious and not already hidden/removed
        if (
            args.maliciousFiles.length > 0 &&
            skill.moderationStatus !== 'hidden' &&
            skill.moderationStatus !== 'removed'
        ) {
            patch.moderationStatus = 'hidden'
            patch.moderationReason = 'Auto-hidden due to VirusTotal malware detection'
            patch.hiddenAt = Date.now()
        }

        await ctx.db.patch(args.skillId, patch)

        if (args.maliciousFiles.length > 0) {
            console.warn(`Skill ${skill.slug} (${args.skillId}) flagged as MALICIOUS by VirusTotal and HIDDEN.`)
        } else if (args.suspiciousFiles.length > 0) {
            console.warn(`Skill ${skill.slug} (${args.skillId}) flagged as SUSPICIOUS by VirusTotal.`)
        } else {
            console.log(`Skill ${skill.slug} (${args.skillId}) scan complete: CLEAN.`)
        }
    },
})
